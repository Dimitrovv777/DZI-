Зад.1
Целта на задачата е да можете да различавате видовете алгоритми. На картинките са показани 
два алгоритъма. Срещу всяка една от картинките трябва да попълните кой от видовете алгоритми
е използван.
Отг.
1-Алгоритъм за търсене на елемент в масив. Използван е алгоритъма линейно търсене.,
2-Алгоритъм за сортиране на елементите в масив. Използван е алгоритъма за сортиране 
чрез пряка селекция.

Зад.2
Обяснете какво прави методът Dequeue()?
Отг.
премахва и връща елемента от началото на опашката

Зад.3
Имате следният програмен фрагмент, който трябва да сортира елементите в подаден списък. В кода има грешка и не работи правилно. 
При примерен вход: 36 15 1 7 20 8 24

Програмата извежда като резултат следното: 1 1 1 7 8 8 24

А трябва да изведе сортираните елементи: 1 7 8 15 20 24 36

var collection = Console.Readline().Split().Select(int.Parse).ToList();
            for (int index = 0; index < collection.Count; index++)
            {
                int min = index;
                for (int curr = index + 1; curr < collection.Count; curr++)
                {
                    if (collection[curr] > collection[min])
                    {
                        min = curr;
                    }
                }
                collection[index] = collection[min];
                collection[min] = collection[index];
            }
            Console.WriteLine(string.Join(" ", collection));

Вашата задача е да откриете грешката, да я поправите и да запишете в полето вече правилно работещ код.
Отг.
var collection = Console.Readline().Split().Select(int.Parse).ToList();
            for (int index = 0; index < collection.Count; index++)
            {
                int min = index;
                for (int curr = index + 1; curr < collection.Count; curr++)
                {
                    if (collection[curr] < collection[min])
                    {
                        min = curr;
                    }
                }

                int temp = collection[index]
                collection[index] = collection[min];
                collection[min] = temp;
            }
            Console.WriteLine(string.Join(" ", collection));

Зад.4
Целта на задачата е да можете да различавате видовете алгоритми. На картинките са 
показани два алгоритъма. Срещу всяка една от картинките трябва да попълните кой от
видовете алгоритми е използван.
Отг.
1-Алгоритъм за търсене на елемент в масив. Използван е алгоритъма двоично търсене.,
2-Алгоритъм за сортиране на елементите в масив. Използван е алгоритъма за сортиране чрез метода на мехурчето.

Зад.5
Да кажем, че играем на игра, в която трябва да познаете числото. Имате списък с числа от  1 до 20 включително подредени във възходящ ред. Решете задачата, като намерите кое е търсеното число и използвания алгоритъм за търсене на числото. 

Намислям си число и ти предполагаш, че числото е 11. Аз ти казвам, че моето число е по-малко. 

Търсиш в числата между 1 и 10. Предполагаш, че моето число е 5. Аз ти казвам, че моето число е по-малко.

Търсиш в числата между 1 и 4. Предполагаш, че моето число е 2. Аз ти казвам, че моето число е по-голямо.

Отг.
Позна ли кое е моето число? [Търсеното число е 3]

Кой алгоритъм за търсене използва? [Двоично търсене]

Зад.6
Имате зададени твърдения за два алгоритъма за търсене - двоично търсене и
линейно търсене. По зададените твърдения и характеристики трябва да сравните 
двата алгоритъма и да зададете коя от тях към кой от алгоритмите се отнася:
Отг.
Стойностите в масива трябва да са сортирани. [Двоично търсене]

Работи във времева сложност O(log n). [Двоично търсене]

Ако ключът е по-малък от средния елемент, тогава ключът може да лежи само в левия подмасив. [Двоично търсене]

Работи във времева сложност O(log(log n)). [Линейно търсене] 

Ако ключът е по-голям от средния елемент, тогава ключът може да лежи само в десния подмасив. [Двоично търсене]

Стойностите в масива не е задължително да са сортирани. [Линейно търсене]

Започва винаги от началото на масива. [Линейно търсене]

Ако ключът съвпада със средния елемент, върнете средното местоположение. [Двоично търсене]

Започва търсенето от средата на масива. [Двоично търсене]

Зад.7
Дадени са следните картинки:

ТУК ИМА СКИМКА !!!
	

Това е визуализация на един от алгоритмите за сортиране. За този алгоритъм важи следното правило: 
Взима първият елемент на масива (29) и го сравнява със следващия (10). В случая следващия елемент е по-малък и стойностите се разменят. След това сравнява вторият елемент, който вече е (29) със следващия (14) и тъй като 14 < 29 отново ги разменя. Алгоритъма разменя стойностите, само ако има нужда от това. Ако следващия елемент (напр. 37) е по-голям от предходния (29) тогава елементите няма да се разменят и сравняването ще продължи вече с новото по-голямо число (37) и следващият елемент (14). Продължава така, докато не подреди елементите в масива. 
Посочете кой от видовете алгоритми е използван:
Отг.
Сортиране на елементите чрез метода на мехурчето.

Зад.8
Имате даден програмен фрамент от код написан на C#.

ТУК ИМА КОД !!!

Съставете програма, която намира най-дългата последователност от равни числа в 
даден списък от цели числа List<int>   и отпечатва като резултат тази най-дълга по
следователност. Ако няколко поредици имат същата най-дълга дължина, върнете най-лявата от тях.
Отг.
class Program

    {

        static void Main(string[] args)

        {

            List<int> nums = Console.ReadLine().Split().Select(int.Parse).ToList();



            int bestStart = 0;

            int bestLength = 1;

            int currentLength = 1;

            int index = 0;

            int first = nums[index];



            for (int i = 1; i < nums.Count; i++)

            {

                if (first == nums[i])

                {

                    currentLength++;

                    if (currentLength > bestLength)

                    {

                        bestLength = currentLength;

                        bestStart = index;

                    }

                }

                else

                {

                    first = nums[i];

                    index = i;

                    currentLength = 1;

                }

            }



            for (int i = bestStart; i < bestStart + bestLength; i++)

            {

                Console.Write($"{nums[i]} ");

            }

        }

    }

Зад.9
Имате следният програмен фрагмент, който трябва да сортира елементите в подаден списък. В кода има грешка и не работи правилно. 
При примерен вход: 36 15 1 7 20 8 24

Програмата извежда като резултат следното: 1 1 1 7 8 8 24

А трябва да изведе сортираните елементи: 1 7 8 15 20 24 36

var list = Console.ReadLine().Split().Select(int.Parse).ToList();
            for (int i = 0; i <= list.Count - 2; i++)
            {
                for (int i = 0; i <= list.Count - 2; i++)
                {
                    if (list[i] < list[i + 1])
                    {
                        list[i] = list[i + 1];
                        list[i + 1] = list[i];
                    }
                }
            }
            Console.WriteLine(string.Join(" ", list));

Вашата задача е да откриете грешката, да я поправите и да запишете в полето вече правилно работещ код.

Отг.
var list = Console.ReadLine().Split().Select(int.Parse).ToList();
            for (int i = 0; i <= list.Count - 2; i++)
            {
                for (int j = 0; j <= list.Count - 2; j++)
                {
                    if (list[j] > list[j + 1])
                    {

                        int temp = list[j];
                        list[j] = list[j + 1];
                        list[j + 1] = temp;
                    }
                }
            }
            Console.WriteLine(string.Join(" ", list));

Зад.10
Посочете вярното за следното твърдение:
Отг.
Посочете вярното за следното твърдение:
[Enqueue] – добавя елемент в края на опашката

Зад.11
Имате дадени твърдения. Вие трябва да можете да различавате и сравнявате 
видовете структури от данни. Срещу всяко едно от тези твърдения трябва да
зададете правилната структура от данни за която то се отнася.
Отг.
За добавяне на елемент в структурата от данни използва операцията Push(T). [Стек]

Можем да обходим елементите в структура от данни тип опашка с  помощта на for-цикъл. [Твърдението не е вярно]

За премахване на елемент от структурата от данни използва операцията Dequeue(). [Опашка]

За премахване на елемент от структурата от данни използва операцията Pop(). [Стек]

Структура от данни, която има поведението първи влязъл първи излязъл. [Опашка]

Можем да достъп елемент от структурата от данни стек, като използваме операцията Peek(index) неговия индекс. [Твърдението не е вярно]

Структура от данни, която има поведението последен влязъл първи излязъл. [Стек]

За добавяне на елемент в структурата от данни използва операцията Enqueue(T). [Опашка]

Зад.12
На картинката е показана част от имплементацията на линейната структура от данни
опашка. Посочете коя имплементация е използвана:
Отг.
Динамична имплементация на опашка

Зад.13
Показани са означенията на типовете сложност на алгоритъм, посочете съответстващата
му сложност, като изберете от падащия списък срещу всяко от означенията:
Отг.
O(n3)        [кубична]

O(log(N))  [логаритмична]

O(N)         [линейна]

O(2n)        [експоненциална]

О(n2)        [квадратична]

O(1)          [константна]

O(N!)        [експоненциална]

Зад.14
Имате зададени твърдения за два алгоритъма за търсене - двоично търсене
и интерполационно търсене. По зададените твърдения и характеристики трябва да 
сравните двата алгоритъма и да зададете коя от тях към кой от алгоритмите се отнася:
Отг.
Стойностите в масива трябва да са сортирани и равномерно разпределени. [Интерполационно търсене]

Работи във времева сложност O(log n). [Двоично търсене]

Ако ключът е по-малък от средния елемент, тогава ключът може да лежи само в левия подмасив. [Отнася се и за двата алгоритъма]

Работи във времева сложност O(log(log n)). [Интерполационно търсене] 

Ако ключът е по-голям от средния елемент, тогава ключът може да лежи само в десния подмасив. [Отнася се и за двата алгоритъма]

Може да се оцени позицията на стойността на ключа в масива,като се вземат предвид най-малкият и най-големият елемент в масива и дължината на масива. [Интерполационно търсене]

Оценява средната позиция за масива и сравнява този елемент с желания ключ. [Интерполационно търсене]

Ако ключът съвпада със средния елемент, върнете средното местоположение. [Отнася се и за двата алгоритъма]

Зад.15
Дефинирайте понятието сложност на алгоритъм, като попълните липсващите думи в текста.
Отг.
Сложност на алгоритъм е [груба оценка на броя стъпки], които алгоритъмът
ще направи в зависимост от [размера на входните данни]. Това 
е груба оценка, която се интересува от [порядъка на броя стъпки], а не от [точния им брой].

Зад.16
Обяснете какво прави методът Enqueue(T)?
Отг.
добавя елемент в края на опашката

Зад.17
Даден е аритметичен израз със скоби (може и вложени).
Цел: извличане на всички под-изрази в скоби
Примерен вход: 
1 + (2 - (2 + 3) * 4 / (3 + 1)) * 5

Изход:

(2 + 3)

(3 + 1)

(2 - (2 + 3) * 4 / (3 + 1))

Имате следният програмен фрагмент. 
В кода има грешка и не работи правилно.

Отг.
class Program

    {

        static void Main(string[] args)

        {

            Stack<int> indexes = new Stack<int>();

            string expression = Console.ReadLine();

            for (int i = 0; i < expression.Length; i++)

            {

                if (expression[i] == '(')

                {

                    indexes.Push(i);

                }

                else if (expression[i] == ')')

                {

                    int startIndex = indexes.Pop();

                    int length = i - startIndex + 1;

                    string substr = expression.Substring(startIndex, length);

                    Console.WriteLine(substr);

                }

            }

        }

    }

Зад.18
Запазете историята на браузъра. Ще получите възможни команди:
URL – отваря дадената страница
back – връща към предната страница
exit – спира програмата
Примерен вход:

www.softuni.bg
www.judge.softuni.bg
www.kids.softuni.bg
back
back
exit

Изход:
www.judge.softuni.bg
www.softuni.bg

Имате следният програмен фрагмент. 
В кода има грешка и не работи правилно.
Отг.
static void Main(string[] args)

        {

            Stack<string> pages = new Stack<string>();

            string command = Console.ReadLine();

            string previous = command;

            while (!"exit".Equals(command))

            {

                if (command.Equals("back"))

                {

                    if (pages.Count != 0)

                    {

                        pages.Pop();

                        Console.WriteLine(pages.Peek());

                    }

                    previous = null;

                }

                else

                {

                    if (previous != null)

                    {

                        pages.Push(command);

                    }

                    previous = command;

                }



                command = Console.ReadLine();



            }

        }

Зад.19
Имате следният програмен фрагмент, който трябва да сортира елементите в подаден списък. В кода има грешка и не работи правилно. 
При примерен вход: 36 15 1 7 20 8 24

Програмата извежда като резултат следното: 1 1 1 7 8 8 24

А трябва да изведе сортираните елементи: 1 7 8 15 20 24 36

var list = Console.ReadLine().Split().Select(int.Parse).ToList();
            for (int j = 0 j <= list.Count - 2; j++)
            {
                for (int i = 0; i <= list.Count - 2; i++)
                {
                    if (list[i] > list[i + 1])
                    {
                        list[i] = list[i + 1];
                        list[i + 1] = list[i];
                    }
                }
            }
            Console.WriteLine(string.Join(" ", list));

Вашата задача е да откриете грешката, да я поправите и да запишете в полето вече правилно работещ код.

Отг.
var list = Console.ReadLine().Split().Select(int.Parse).ToList();

            for (int i = 0; i <= list.Count - 2; i++)

            {

                for (int j = 0; j <= list.Count - 2; j++)

                {

                    if (list[j] > list[j + 1])

                    {



                        int temp = list[j];

                        list[j] = list[j + 1];

                        list[j + 1] = temp;

                    }

                }

            }

            Console.WriteLine(string.Join(" ", list));

Зад.20
Дайте пример с C# код, за метод който да сортира  елементите от списъка List<int> list = new List<int>() { 12, 8, 10, 2, 9, 6, 1}; посредством алгоритъма за сортиране  чрез метода на мехурчето.
Отг.
class Program
{

public static void BubbleSort(List<int> list)

{

            for (int i = 0; i <= list.Count - 2; i++)

            {

                for (int j = 0; j <= list.Count - 2; j++)

                {

                    if (list[j] > list[j + 1])

                    {



                        int temp = list[j];

                        list[j] = list[j + 1];

                        list[j + 1] = temp;

                    }

                }

            }

            Console.WriteLine(string.Join(" ", list));

}

static void Main()

{

var list = Console.ReadLine().Split().Select(int.Parse).ToList();

BubbleSort(list);

}

}

Зад.21
Изчислете какъв ще бъде отговорът на следния пример:

През 2013 ООН има 193 страни членки. Ако имената на тези страни са сортирани по азбучен ред в масив, колко имена трябва да провери двоичното търсене, за да намери конкретно име в масива в най-лошия случай?
отг.
[Не повече от 8.]

Зад.22
ТУК ИМА СНИМКА !!!
На картинката е показана част от имплементацията на линейната структура от данни опашка. Посочете коя имплементация е използвана:
Отг.
Статична имплементация на опашка







































